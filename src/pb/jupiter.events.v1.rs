// @generated
// This file is @generated by prost-build.
/// Jupiter program IDs
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JupiterPrograms {
    /// JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4
    #[prost(string, tag="1")]
    pub jupiter_swap_v6: ::prost::alloc::string::String,
    /// JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB
    #[prost(string, tag="2")]
    pub jupiter_swap_v4: ::prost::alloc::string::String,
    /// JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB
    #[prost(string, tag="3")]
    pub jupiter_swap_v3: ::prost::alloc::string::String,
    /// JUP3c2Uh3WA4Ng34tw6kPd2G4C5BB21Xo36Je1s32Ph
    #[prost(string, tag="4")]
    pub jupiter_swap_v2: ::prost::alloc::string::String,
    /// JUP2jxvXaqu7NQY1GmNF4m1vodw12LVXYxbFL2uJvfo
    #[prost(string, tag="5")]
    pub jupiter_swap_v1: ::prost::alloc::string::String,
    /// jupoNjAxXgZ4rjzxzPMP4oxduvQsQtZzyknqvzYNrNu
    #[prost(string, tag="6")]
    pub jupiter_limit_order: ::prost::alloc::string::String,
    /// DCA265Vj8a9CEuX1eb1LWRnDT7uK6q1xMipnNyatn23M
    #[prost(string, tag="7")]
    pub jupiter_dca: ::prost::alloc::string::String,
}
/// Main Jupiter events container
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JupiterEvents {
    #[prost(message, repeated, tag="1")]
    pub swap_events: ::prost::alloc::vec::Vec<SwapEvent>,
    #[prost(message, repeated, tag="2")]
    pub limit_order_events: ::prost::alloc::vec::Vec<LimitOrderEvent>,
    #[prost(message, repeated, tag="3")]
    pub dca_events: ::prost::alloc::vec::Vec<DcaEvent>,
    #[prost(message, repeated, tag="4")]
    pub aggregation_events: ::prost::alloc::vec::Vec<AggregationEvent>,
    #[prost(uint64, tag="5")]
    pub block_number: u64,
    #[prost(string, tag="6")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag="7")]
    pub timestamp: u64,
}
/// Swap events from Jupiter
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapEvents {
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<SwapEvent>,
    #[prost(uint64, tag="2")]
    pub block_number: u64,
    #[prost(string, tag="3")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag="4")]
    pub timestamp: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapEvent {
    #[prost(string, tag="1")]
    pub transaction_signature: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub input_mint: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub output_mint: ::prost::alloc::string::String,
    #[prost(uint64, tag="5")]
    pub input_amount: u64,
    #[prost(uint64, tag="6")]
    pub output_amount: u64,
    #[prost(uint64, tag="7")]
    pub minimum_amount_out: u64,
    #[prost(uint64, tag="8")]
    pub price_impact_pips: u64,
    #[prost(message, repeated, tag="9")]
    pub routes: ::prost::alloc::vec::Vec<SwapRoute>,
    #[prost(string, tag="10")]
    pub program_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="11")]
    pub slot: u64,
    #[prost(uint64, tag="12")]
    pub timestamp: u64,
    /// v1, v2, v3, v4, v6
    #[prost(string, tag="13")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration="SwapStatus", tag="14")]
    pub status: i32,
    #[prost(string, tag="15")]
    pub error_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapRoute {
    #[prost(string, tag="1")]
    pub dex: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub program_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub input_mint: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub output_mint: ::prost::alloc::string::String,
    #[prost(uint64, tag="5")]
    pub input_amount: u64,
    #[prost(uint64, tag="6")]
    pub output_amount: u64,
    #[prost(uint64, tag="7")]
    pub price_impact_pips: u64,
    #[prost(string, repeated, tag="8")]
    pub accounts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Limit Order events
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LimitOrderEvents {
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<LimitOrderEvent>,
    #[prost(uint64, tag="2")]
    pub block_number: u64,
    #[prost(string, tag="3")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag="4")]
    pub timestamp: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LimitOrderEvent {
    #[prost(string, tag="1")]
    pub transaction_signature: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub input_mint: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub output_mint: ::prost::alloc::string::String,
    #[prost(uint64, tag="6")]
    pub input_amount: u64,
    #[prost(uint64, tag="7")]
    pub output_amount: u64,
    #[prost(uint64, tag="8")]
    pub price: u64,
    #[prost(enumeration="LimitOrderType", tag="9")]
    pub order_type: i32,
    #[prost(enumeration="LimitOrderStatus", tag="10")]
    pub status: i32,
    #[prost(uint64, tag="11")]
    pub slot: u64,
    #[prost(uint64, tag="12")]
    pub timestamp: u64,
    #[prost(string, tag="13")]
    pub error_message: ::prost::alloc::string::String,
}
/// DCA (Dollar Cost Averaging) events
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DcaEvents {
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<DcaEvent>,
    #[prost(uint64, tag="2")]
    pub block_number: u64,
    #[prost(string, tag="3")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag="4")]
    pub timestamp: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DcaEvent {
    #[prost(string, tag="1")]
    pub transaction_signature: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub dca_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub input_mint: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub output_mint: ::prost::alloc::string::String,
    #[prost(uint64, tag="6")]
    pub amount_per_interval: u64,
    #[prost(uint64, tag="7")]
    pub interval_seconds: u64,
    #[prost(uint64, tag="8")]
    pub next_execution: u64,
    #[prost(enumeration="DcaStatus", tag="9")]
    pub status: i32,
    #[prost(uint64, tag="10")]
    pub slot: u64,
    #[prost(uint64, tag="11")]
    pub timestamp: u64,
    #[prost(string, tag="12")]
    pub error_message: ::prost::alloc::string::String,
}
/// Aggregation events (routing decisions, arbitrage opportunities)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationEvents {
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<AggregationEvent>,
    #[prost(uint64, tag="2")]
    pub block_number: u64,
    #[prost(string, tag="3")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag="4")]
    pub timestamp: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationEvent {
    #[prost(string, tag="1")]
    pub transaction_signature: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub available_dexs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="4")]
    pub selected_route: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="5")]
    pub alternative_routes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag="6")]
    pub price_impact_pips: u64,
    #[prost(uint64, tag="7")]
    pub estimated_slippage: u64,
    #[prost(enumeration="AggregationType", tag="8")]
    pub r#type: i32,
    #[prost(uint64, tag="9")]
    pub slot: u64,
    #[prost(uint64, tag="10")]
    pub timestamp: u64,
}
/// Enums
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SwapStatus {
    Unknown = 0,
    Pending = 1,
    Success = 2,
    Failed = 3,
    Cancelled = 4,
}
impl SwapStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SwapStatus::Unknown => "SWAP_STATUS_UNKNOWN",
            SwapStatus::Pending => "SWAP_STATUS_PENDING",
            SwapStatus::Success => "SWAP_STATUS_SUCCESS",
            SwapStatus::Failed => "SWAP_STATUS_FAILED",
            SwapStatus::Cancelled => "SWAP_STATUS_CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SWAP_STATUS_UNKNOWN" => Some(Self::Unknown),
            "SWAP_STATUS_PENDING" => Some(Self::Pending),
            "SWAP_STATUS_SUCCESS" => Some(Self::Success),
            "SWAP_STATUS_FAILED" => Some(Self::Failed),
            "SWAP_STATUS_CANCELLED" => Some(Self::Cancelled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LimitOrderType {
    Unknown = 0,
    Buy = 1,
    Sell = 2,
}
impl LimitOrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LimitOrderType::Unknown => "LIMIT_ORDER_TYPE_UNKNOWN",
            LimitOrderType::Buy => "LIMIT_ORDER_TYPE_BUY",
            LimitOrderType::Sell => "LIMIT_ORDER_TYPE_SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LIMIT_ORDER_TYPE_UNKNOWN" => Some(Self::Unknown),
            "LIMIT_ORDER_TYPE_BUY" => Some(Self::Buy),
            "LIMIT_ORDER_TYPE_SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LimitOrderStatus {
    Unknown = 0,
    Pending = 1,
    Filled = 2,
    Cancelled = 3,
    Expired = 4,
}
impl LimitOrderStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LimitOrderStatus::Unknown => "LIMIT_ORDER_STATUS_UNKNOWN",
            LimitOrderStatus::Pending => "LIMIT_ORDER_STATUS_PENDING",
            LimitOrderStatus::Filled => "LIMIT_ORDER_STATUS_FILLED",
            LimitOrderStatus::Cancelled => "LIMIT_ORDER_STATUS_CANCELLED",
            LimitOrderStatus::Expired => "LIMIT_ORDER_STATUS_EXPIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LIMIT_ORDER_STATUS_UNKNOWN" => Some(Self::Unknown),
            "LIMIT_ORDER_STATUS_PENDING" => Some(Self::Pending),
            "LIMIT_ORDER_STATUS_FILLED" => Some(Self::Filled),
            "LIMIT_ORDER_STATUS_CANCELLED" => Some(Self::Cancelled),
            "LIMIT_ORDER_STATUS_EXPIRED" => Some(Self::Expired),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DcaStatus {
    Unknown = 0,
    Active = 1,
    Paused = 2,
    Completed = 3,
    Cancelled = 4,
}
impl DcaStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DcaStatus::Unknown => "DCA_STATUS_UNKNOWN",
            DcaStatus::Active => "DCA_STATUS_ACTIVE",
            DcaStatus::Paused => "DCA_STATUS_PAUSED",
            DcaStatus::Completed => "DCA_STATUS_COMPLETED",
            DcaStatus::Cancelled => "DCA_STATUS_CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DCA_STATUS_UNKNOWN" => Some(Self::Unknown),
            "DCA_STATUS_ACTIVE" => Some(Self::Active),
            "DCA_STATUS_PAUSED" => Some(Self::Paused),
            "DCA_STATUS_COMPLETED" => Some(Self::Completed),
            "DCA_STATUS_CANCELLED" => Some(Self::Cancelled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggregationType {
    Unknown = 0,
    RouteSelection = 1,
    Arbitrage = 2,
    LiquidityOptimization = 3,
    SlippageProtection = 4,
}
impl AggregationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AggregationType::Unknown => "AGGREGATION_TYPE_UNKNOWN",
            AggregationType::RouteSelection => "AGGREGATION_TYPE_ROUTE_SELECTION",
            AggregationType::Arbitrage => "AGGREGATION_TYPE_ARBITRAGE",
            AggregationType::LiquidityOptimization => "AGGREGATION_TYPE_LIQUIDITY_OPTIMIZATION",
            AggregationType::SlippageProtection => "AGGREGATION_TYPE_SLIPPAGE_PROTECTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGGREGATION_TYPE_UNKNOWN" => Some(Self::Unknown),
            "AGGREGATION_TYPE_ROUTE_SELECTION" => Some(Self::RouteSelection),
            "AGGREGATION_TYPE_ARBITRAGE" => Some(Self::Arbitrage),
            "AGGREGATION_TYPE_LIQUIDITY_OPTIMIZATION" => Some(Self::LiquidityOptimization),
            "AGGREGATION_TYPE_SLIPPAGE_PROTECTION" => Some(Self::SlippageProtection),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
